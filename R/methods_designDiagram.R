#' @title The \code{designDiagram} class and some basic methods
#'
#' @name designDiagram-class
#' @description
#' Objects of class \code{designDiagram} as generated by \code{\link{DD}} is a list with entries as specified below.
#' \describe{
#'   \item{\code{terms}}{Named vector with all terms in the design.}
#'   \item{\code{random.terms}}{Vector with the random terms in the design.}
#'   \item{\code{Nparm}}{Named vector with the number of parameters for the terms.}
#'   \item{\code{df}}{Named vector with the degrees of freedom for the terms.}
#'   \item{\code{collinearities}}{Named vector with the number of (approximate) collinearities that have been removed from the terms.}
#'   \item{\code{SS}}{Named vector with Sum-of-Squares if a response variable was specified.}
#'   \item{\code{MSS}}{Named vector with Mean-Sum-of-Squares if a response variable was specified.}
#'   \item{\code{relations}}{Named matrix with relations between variables with the following interpretation: "0"=linear indepent, "<"=row term is a subspace of column, "<-"=row term is a subspace of column term and no other terms are inbetween, ">" and "->" the similar interpretatioin between columns and rows, name=name of minimum between row and column term.}
#'   \item{\code{pvalue}}{Named matrix with p-values for F-tests. p-values are stated at the collapsed nesting, but F-test are done against the most coarse nested random effect.}
#'   \item{\code{inner}}{Named matrix of squared inner products of subspaces with nesting subspaces removed. Rouded at 6'th digits, and used to decide orthogonality of the design.}
#'   \item{\code{response}}{Logical stating whether a response variable was present.}
#' }
#' 
#' @param x object of class \code{designDiagram}
#' @param circle character specifying which circles to draw at the terms: \code{"none"}=no circles, \code{"SS"}=a circle with area proportional to the associated Sum-of-Squares, \code{"MSS"}=a circle with area proportional to the associated Mean-Sum-of-Squares. The two latter options are only available if a response variable was specified for the design. Defaults to \code{"none"}.
#' @param pvalue boolean specifying whether p-values should be inserted on the graphs. This is only possible if a response variable was specified. Defaults to \code{TRUE} is \code{circle="MSS"} and \code{FALSE} otherwise.
#' @param kill.intercept boolean specifying whether circle for the intercept should be removed. This is practicable since the intercept term otherwise may overweight the remaining terms. Defaults to \code{TRUE}.
#' @param diam diameter of largest circle. For layout purposes only. Defaults to 80.
#' @param color color of circles. Defaults to \code{"lightgreen"} for Sum-of-Squares and to \code{"lightblue"} for Mean-Sum-of-Squares.
#' @param border border margins. May either be given as a single numeric, or as 4-vector giving lower-left-upper-right margins.
#' @param \dots Not used.
#' 
#' @seealso \code{\link{DD}}
#' 
#' @importFrom graphics plot
#' @importFrom stats as.formula formula model.frame model.matrix model.response pf pt qt quantile r2dtable rmultinom rt terms
#' @importFrom ggplot2 ggplot
#' @importFrom igraph make_graph set_vertex_attr E E<- layout_with_sugiyama %>%

#' @rdname designDiagram-class
#' @export
print.designDiagram <- function(x,...) {
  # Table of dimensions
  if (any(x$inner[upper.tri(x$inner)]!=0)) {
    cat("Non-orthogonal design with dimensions:\n")
  } else {
    cat("Orthogonal design with dimensions:\n")
  }
  print(rbind(Nparm=x$Nparm,df=x$df,Ncol=x$collinearities))
}


#' @rdname designDiagram-class
#' @export
summary.designDiagram <- function(x,...) {
  # Table of dimensions
  if (any(x$inner[upper.tri(x$inner)]!=0)) {
    cat("Non-orthogonal design with dimensions:\n")
  } else {
    cat("Orthogonal design with dimensions:\n")
  }
  print(rbind(Nparm=x$Nparm,df=x$df,Ncol=x$collinearities))
  
  # Table of inner products
  if (any(x$inner[upper.tri(x$inner)]!=0)) {
    cat("\n")
    cat("Note: Sum-of-Squares and p-values may depend on order of terms in an non-orthogonal design.\n")
    cat("\n")
    cat("Total inner products between subspaces (used to decide orthogonality):\n")
    print(x$inner)
  }
  
  # Table of relations
  cat("\n")
  cat("Table of relations:\n")
  print(x$relations)
  
  # Additional output if response is present
  cat("\n")
  if (!x$response) {
    cat("No response variable specified.\n")
  } else {
    cat("Orthogonal decomposition of response variable:\n")
    print(rbind(SS=x$SS,MSS=x$MSS))
    cat("\n")
    cat("P-values for F-tests against nested random effect:\n")
    print(signif(x$pvalue,6))
  }
}

#' @rdname designDiagram-class
#' @export
plot.designDiagram <- function(x,circle="none",pvalue=(circle=="MSS"),kill.intercept=TRUE,
                               diam=80,color=ifelse(circle=="MSS","lightblue","lightgreen"),
                               border=c(0,0.1,0.1,0.2),
                               ...) {
  
  # sanity check
  if (!is.element(circle,c("none","SS","MSS"))) stop("circle-argumente must be either none, SS, or MSS")
  if ((!x$response) & (is.element(circle,c("SS","MSS")))) {
    circle <- "none"
    warning("Sum of Squares unavailable")
  }
  if (length(border)==1) border <- rep(border,4)

  # set-up basic graph
  N <- length(x$terms)
  myedges <- c(sapply(which(x$relations=="<-"),function(z){c(1+(z-1)%/%N,1+(z-1)%%N)}))
  g <- make_graph(myedges,directed=TRUE) %>% set_vertex_attr("label",value=rep(" ",N))
  if (pvalue) E(g)$label <- as.character(signif(x$pvalue[x$relations=="<-"],digits=3))
  lay1 <- layout_with_sugiyama(g,attributes="all")

  # takeout layout and turn the vertical direction: NOT USED ANYMORE
  #tmp     <- get.graph.attribute(lay1$extd_graph)$layout
  #y.max   <- 1+max(tmp[,2])
  #tmp[,2] <- y.max-tmp[,2]
  #lay1$extd_graph <- set_graph_attr(lay1$extd_graph,"layout",tmp)
  #tmp     <- lay1$layout
  #tmp[,2] <- y.max-tmp[,2]
  #lay1$layout <- tmp
  #tmp     <- lay1$layout.dummy
  #tmp[,2] <- y.max-tmp[,2]
  #lay1$layout.dummy <- tmp
  
  # Plain design diagram
  if (circle=="none") {
    plot(lay1$extd_graph,
         vertex.size=c(rep(30,length(lay1$layout)/2),rep(0,length(lay1$layout.dummy)/2)),
         vertex.color=NA,vertex.frame.color=NA,
         rescale=FALSE,
         xlim=c(min(lay1$layout[,1])-border[2],max(lay1$layout[,1])+border[4]),
         ylim=c(min(lay1$layout[,2])-border[1],max(lay1$layout[,2])+border[3]))
  }
  
  # Design diagram with circles
  if (is.element(circle,c("SS","MSS"))) {
    # find circle diameters
    if (circle=="SS") {area <- x$SS} else {area <- x$MSS}
    if (kill.intercept & (is.element("1",names(area)))) area["1"] <- 0
    diam <- diam*sqrt(area/max(area,na.rm=TRUE))
    diam[is.na(diam)] <- 0
    diam[is.nan(diam)] <- 0
    # make graph
    plot(lay1$extd_graph,
         vertex.size=c(diam,rep(0,length(lay1$layout.dummy)/2)),
         vertex.color=color,vertex.frame.color=NA,
         rescale=FALSE,
         xlim=c(min(lay1$layout[,1])-border[2],max(lay1$layout[,1])+border[4]),
         ylim=c(min(lay1$layout[,2])-border[1],max(lay1$layout[,2])+border[3]))
  }
  
  # insert vertex names
  for (i in 1:N) {
    if (x$collinearities[i]==0) {
      text(lay1$layout[i,1],lay1$layout[i,2],cex=1.2,
           substitute(x[b]^a,list(x=names(x$terms)[i],a=x$Nparm[i],b=x$df[i])))
    } else {
      tmp <- x$collinearities[i]
      text(lay1$layout[i,1],lay1$layout[i,2],cex=1.2,
           substitute(x[b-c]^a,list(x=names(x$terms)[i],a=x$Nparm[i],b=x$df[i]+tmp,c=tmp)))
    }
  }
}
