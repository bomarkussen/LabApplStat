#' @title The \code{designDiagram} class and some basic methods
#'
#' @name designDiagram-class
#' @description
#' Objects of class \code{designDiagram} as generated by \code{\link{DD}} is a list with entries as specified below.
#' \describe{
#'   \item{\code{terms}}{Named vector with all terms in the design.}
#'   \item{\code{random.terms}}{Vector with the random terms in the design.}
#'   \item{\code{Nparm}}{Named vector with the number of parameters for the terms.}
#'   \item{\code{df}}{Named vector with the degrees of freedom for the terms.}
#'   \item{\code{collinearities}}{Named vector with the number of (approximate) collinearities that have been removed from the terms.}
#'   \item{\code{SS}}{Named vector with Sum-of-Squares if a response variable was specified.}
#'   \item{\code{MSS}}{Named vector with Mean-Sum-of-Squares if a response variable was specified.}
#'   \item{\code{relations}}{Named matrix with relations between variables with the following interpretation: "0"=linear indepent, "<"=row term is a subspace of column, "<-"=row term is a subspace of column term and no other terms are inbetween, ">" and "->" the similar interpretatioin between columns and rows, name=name of minimum between row and column term.}
#'   \item{\code{pvalue}}{Named matrix with p-values for F-tests. p-values are stated at the collapsed nesting, but F-test are done against the most coarse nested random effect.}
#'   \item{\code{inner}}{Named matrix of squared inner products of subspaces with nesting subspaces removed. Rouded at 6'th digits, and used to decide orthogonality of the design.}
#'   \item{\code{response}}{Logical stating whether a response variable was present.}
#' }
#' 
#' @param x object of class \code{designDiagram}
#' @param circle character specifying which circles to draw at the terms: \code{"none"}=no circles, \code{"SS"}=a circle with area proportional to the associated Sum-of-Squares, \code{"MSS"}=a circle with area proportional to the associated Mean-Sum-of-Squares. The two latter options are only available if a response variable was specified for the design. Defaults to \code{"none"}.
#' @param pvalue boolean specifying whether p-values should be inserted on the graphs. This is only possible if a response variable was specified. Defaults to \code{TRUE} is \code{circle="MSS"} and \code{FALSE} otherwise.
#' @param kill.intercept boolean specifying whether circle for the intercept should be removed. This is practicable since the intercept term otherwise may overweight the remaining terms. Defaults to \code{TRUE}.
#' @param color color of circles. Defaults to \code{"lightgreen"} for Sum-of-Squares and to \code{"lightblue"} for Mean-Sum-of-Squares.
#' @param circle.scaling numeric specifying size scaling of circles. Defaults to \code{1}, which corresponds to the largest circle having a radius that is half of the shortest distance between two nodes.
#' @param arrow.type specifying arrow heads via \code{\link{arrow}}. Defaults to \code{arrow(angle=20,length=unit(4,"mm"))}.
#' @param xlim x-range of diagram plot. Defaults to \code{c(0,1)}.
#' @param ylim y-range of diagram plot. Defaults to \code{c(0,1)}.
#' @param horizontal boolen specifying if the design diagram should be drawn horizontally or vertically. Defauls to \code{TRUE}.
#' 
#' @seealso \code{\link{DD}}
#' 
#' @importFrom stats as.formula formula model.frame model.matrix model.response pf pt qt quantile r2dtable rmultinom rt terms
#' @importFrom ggplot2 unit geom_blank geom_label coord_fixed 
#' @importFrom ggraph create_layout ggraph geom_node_circle geom_node_text geom_edge_link label_rect 
#' @importFrom grid convertX convertY
#' @rdname designDiagram-class
#' @export
print.designDiagram <- function(x,...) {
  # Table of dimensions
  if (any(x$inner[upper.tri(x$inner)]!=0)) {
    cat("Non-orthogonal design with dimensions:\n")
  } else {
    cat("Orthogonal design with dimensions:\n")
  }
  print(rbind(Nparm=x$Nparm,df=x$df,Ncol=x$collinearities))
}


#' @rdname designDiagram-class
#' @export
summary.designDiagram <- function(x,...) {
  # Table of dimensions
  if (any(x$inner[upper.tri(x$inner)]!=0)) {
    cat("Non-orthogonal design with dimensions:\n")
  } else {
    cat("Orthogonal design with dimensions:\n")
  }
  print(rbind(Nparm=x$Nparm,df=x$df,Ncol=x$collinearities))
  
  # Table of inner products
  if (any(x$inner[upper.tri(x$inner)]!=0)) {
    cat("\n")
    cat("Note: Sum-of-Squares and p-values may depend on order of terms in an non-orthogonal design.\n")
    cat("\n")
    cat("Total inner products between subspaces (used to decide orthogonality):\n")
    print(x$inner)
  }
  
  # Table of relations
  cat("\n")
  cat("Table of relations:\n")
  print(x$relations)
  
  # Additional output if response is present
  cat("\n")
  if (!x$response) {
    cat("No response variable specified.\n")
  } else {
    cat("Orthogonal decomposition of response variable:\n")
    print(rbind(SS=x$SS,MSS=x$MSS))
    cat("\n")
    cat("P-values for F-tests against nested random effect:\n")
    print(signif(x$pvalue,6))
  }
}

#' @rdname designDiagram-class
#' @export
plot.designDiagram <- function(x,circle="none",pvalue=(circle=="MSS"),kill.intercept=TRUE,
                               color=ifelse(circle=="MSS","lightblue","lightgreen"),
                               circle.scaling=1,
                               arrow.type=arrow(angle=20,length=unit(4,"mm")),
                               xlim=c(0,1),ylim=c(0,1),
                               horizontal=TRUE) {
  # data frame with edges 
  g.df <- data.frame(from=as.character(1+(which(x$relations=="<-")-1)%/%length(x$terms)),
                     to=as.character(1+(which(x$relations=="<-")-1)%%length(x$terms)),
                     pvalue=paste0("p=",signif(x$pvalue[x$relations=="<-"],digits=3)))
  g.df$pvalue[g.df$pvalue=="p=NA"] <- NA 
  
  # Sugiyama layout scaled in box specified by xlim and ylim
  g <- create_layout(g.df,"sugiyama",maxiter=200)
  if (horizontal) {
    tmp <- g$x
    g$x <- -g$y
    g$y <- tmp
  }
  if (max(g$x)>min(g$x)) {
    g$x <- xlim[1] + (xlim[2]-xlim[1])*(g$x-min(g$x))/(max(g$x)-min(g$x))
  } else {
    g$x <- mean(xlim)
  }
  if (max(g$y)>min(g$y)) {
    g$y <- ylim[1] + (ylim[2]-ylim[1])*(g$y-min(g$y))/(max(g$y)-min(g$y))
  } else {
    g$y <- mean(ylim)
  }
  
  # Text labels
  g$text  <- paste0('"',x$terms,'"[',x$df,']^',x$Nparm)[as.numeric(g$name)]
  g$text0 <- paste0(x$terms,x$Nparm)[as.numeric(g$name)]
  
  # Radii of circles
  if (is.element(circle,c("SS","MSS"))) {
    # choose maximal radius
    max.r <- circle.scaling*0.5*sqrt(outer(g$x,g$x,"-")^2 + outer(g$y,g$y,"-")^2)
    max.r <- min(max.r[upper.tri(max.r)])
    # find circle radii
    if (circle=="SS") {area <- x$SS} else {area <- x$MSS}
    if (kill.intercept & (is.element("1",names(area)))) area["1"] <- 0
    g$r <- (max.r*sqrt(area/max(area,na.rm=TRUE)))[as.numeric(g$name)]
    g$r[is.na(g$r)] <- 0
    g$r[is.nan(g$r)] <- 0
  } else {
    g$r <- 0
  }
  
  # make graph
  p <- ggraph(g) + 
    geom_blank(aes(x=x-0.5*diff(xlim)*grid::convertX(unit(attr(label_rect(text0,fontsize=18),"width"),"cm"),"npc",valueOnly = TRUE),
                   y=y-0.5*diff(ylim)*grid::convertY(unit(attr(label_rect(text0,fontsize=18),"height"),"cm"),"npc",valueOnly = TRUE))) +
    geom_blank(aes(x=x+0.5*diff(xlim)*grid::convertX(unit(attr(label_rect(text0,fontsize=18),"width"),"cm"),"npc",valueOnly = TRUE),
                   y=y+0.5*diff(ylim)*grid::convertY(unit(attr(label_rect(text0,fontsize=18),"height"),"cm"),"npc",valueOnly = TRUE)))
  if (is.element(circle,c("SS","MSS"))) {
    p <- p + geom_node_circle(aes(r=r),col=color,fill=color) +
      coord_fixed()
  }
  p <- p + geom_node_text(aes(x=x,y=y,label=text),parse=TRUE)
  p <- p + geom_edge_link(aes(start_cap=label_rect(node1.text0),
                              end_cap=label_rect(node2.text0)),
                          arrow=arrow.type)
  if (pvalue) {
    p <- p + geom_label(aes(x=(xend+x)/2, 
                            y=(yend+y)/2 - diff(ylim)*grid::convertY(unit(4,"mm"),"npc",valueOnly=TRUE)*(yend==y), label=pvalue), get_edges(),
                        label.padding = unit(0.15,"lines"))
  }
  
  # return graph
  return(p)
}
